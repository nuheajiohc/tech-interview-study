## 1. 배열이 무엇인가요?

<details>
<summary>1번 정답</summary>
<div markdown="1">
 <strong>고정적인 저장공간</strong>에 데이터를 메모리상에 <strong>연속적으로 저장</strong>하는 자료구조
</div>
</details>
<hr>

## 2. 배열의 시간복잡도와 관련된 특징에 대해 설명하고 단점에 대해서 설명해보세요

<details>
<summary>2번 정답</summary>
<div markdown="1">
특징 : 데이터 접근과 마지막 요소 뒤에 새로운 요소 추가, 마지막 요소 삭제의 시간복잡도가 O(1)이고, 중간에 데이터를 추가하고 삭제하는 것은 O(n)입니다.
<br>
시간복잡도에 대한 이유 : 배열을 선언할 때 그 배열의 처음 위치인 인덱스 0번의 주소값을 알 수 있습니다.<br> 그리고 각 데이터에 할당된 주소 공간의 크기는 모두 같기 때문에 접근하고 싶은 인덱스에 공간 크기를 곱하면 해당 위치에 바로 접근할 수 있습니다.<br> 그렇기 때문에 O(1)에 접근이 가능합니다.
<br>
중간에 데이터를 추가하거나 삭제하는 경우에는 해당 데이터 뒤에 있는 데이터들의 개수만큼 당기거나 미뤄줘야하기 때문에 그 데이터의 개수만큼 시간복잡도가 늘어나게 됩니다.
<br>
단점 : 고정적인 저장공간을 가져야 된다는 특징때문에 메모리의 낭비나 오버헤드(특정 기능을 수행하는데 추가적으로 드는 간접적인 시간)가 발생할 수 있습니다.
</div>
</details>
<hr>

## 3. 배열에서 처음 선언한 저장공간보다 더 많은 공간을 사용해야 한다면 어떻게 해야하나요?

<details>
<summary>3번 정답</summary>
<div markdown="1">
배열은 선언할 때 고정된 저장공간을 가지기 때문에 그 이상의 데이터를 추가할 수 없습니다.<br>
하지만 dynamic array를 사용하면 저장공간이 가득 찰 때 resize하여 유동적으로 공간을 조절하여 데이터를 저장할 수 있습니다.
</div>
</details>
<hr>

## 4. 동적배열에서 리사이즈를 어떻게 하나요?

<details>
<summary>4번 정답</summary>
<div markdown="1">
데이터를 추가할 때, 기존에 할당된 배열의 크기를 초과하게 되면 원래 배열크기의 두 배 사이즈를 할당하게 됩니다.<br>
이 때 기존의 배열을 복사하여 새로운 주소 공간에 복사하기 때문에 시간복잡도는 O(n)이 걸리게 됩니다.<br>
하지만 리사이즈 되는 경우는 자주 일어나는 일이 아니므로 전체적으로는 데이터 추가할 때 시간복잡도가 O(1)이 걸린다고 보면 됩니다. 더 정확히 말하자면 amortized O(1)이 걸리게 됩니다.
</div>
</details>
<hr>

## 5. 연결리스트가 무엇인가요?

<details>
<summary>5번 정답</summary>
<div markdown="1">
연결리스트는 노드라는 구조체로 이루어져 있고, 노드는 데이터 값과 다음 노드의 주소를 저장하게 됩니다. 그렇기 때문에 연결리스트는 물리적인 메모리상에서는 비연속적으로 저장이 되지만 다음 노드의 주소를 알기 때문에 논리적인 연속성을 가진 자료구조입니다.
</div>
</details>
<hr>

## 6. 연결리스트의 특징을 시간복잡도와 관련해서 설명해보세요

<details>
<summary>6번 정답</summary>
<div markdown="1">
연결리스트에서 데이터의 추가와 삭제는 배열과는 다르게 시간복잡도가 O(1)입니다. 왜냐하면 물리적인 메모리 위치를 옮길 필요 없이 다음 요소를 가리키는 주소값만 변경하면 되기 때문입니다.
하지만 데이터에 접근하는 것은 해당 요소를 바로 찾을 수 없어서 첫번째 노드부터 차례대로 찾아가야 합니다. 그래서 시간복잡도는 O(n)이 됩니다.
</div>
</details>
<hr>

## 7. Queue는 무슨 자료구조인가요?

<details>
<summary>7번 정답</summary>
<div markdown="1">
queue는 선입선출 FIFO(First In First Out)의 자료구조입니다. 시간복잡도는 데이터 추가(enqueue)와 추출(dequeue)하는 경우 모두 O(1)입니다.
활용 예시에는 Cache구현, 프로세스 관리, 너비우선탐색이 있습니다.
</div>
</details>
<hr>

## 8. Queue를 구현하는 방식에 대해 설명해주세요

<details>
<summary>8번 정답</summary>
<div markdown="1">
Queue 구현은 배열방식과 리스트 방식 모두 구현이 가능합니다.<br>
하지만 배열방식으로 구현할 경우 데이터 추출의 과정에서 남는 메모리가 생기게 돼서 메모리의 낭비가 발생합니다. 그래서 그러한 낭비를 줄이기 위해서 원형 큐 방식으로 구현합니다.<br>
원형 큐 방식은 마지막 인덱스에 도달했을 때, 다시 0번 인덱스부터 queue가 채워지기때문에 메모리의 낭비를 막을 수 있습니다.<br>
연결리스트 방식은 재할당이나 메모리 낭비의 걱정을 할 필요가 없이 구현이 가능하지만, 배열 방식보다 복잡하다는 단점이 있습니다.
</div>
</details>
<hr>

## 9. Stack은 어떤 자료구조인가요?

<details>
<summary>9번 정답</summary>
<div markdown="1">
stack은 후입선출 LIFO의 자료구조입니다. 시간복잡도는 추가, 추출 모두 O(1)입니다.<br>
활용 예시는 후위 표기법 연산(복합 계산기), 괄호 유효성 검사, 웹 브라우저 방문기록(뒤로가기), 깊이우선탐색(DFS) 등이 있습니다.
</div>
</details>
<hr>

## 10. 우선순위 큐와 Heap에 대해 설명해보세요

<details>
<summary>10번 정답</summary>
<div markdown="1">
우선순위 큐는 먼저 들어오는 데이터가 먼저 나가는 것이 아니라 우선순위가 높은 데이터가 먼저 나가는 형태의 자료구조입니다.<br> 우선순위 큐는 일반적으로 힙(Heap)을 이용하여 구현하게 됩니다.<br>
힙은 완전이진트리 형태의 자료구조이고, 데이터 추가와 추출 모두 시간복잡도 O(logN)입니다.
</div>
</details>
<hr>

## 11. hash table은 어떤 자료구조인가요?

<details>
<summary>11번 정답</summary>
<div markdown="1">
hash table은 효율적인 탐색을 위한 자료구조입니다. key-value쌍으로 데이터를 저장합니다.<br>
hash table이 빠른 검색속도를 제공할 수 있는 이유는 내부적으로 배열을 사용하여 데이터를 저장하기 때문입니다.<br> 해시 테이블은 각각의 key 값에 해시 함수를 적용해 배열의 고유한 index를 생성하고 그 값을 활용해 값을 저장하거나 검색하게 됩니다.<br> 그래서 저장, 삭제, 검색의 시간복잡도는 모두 O(1)입니다.
<a href="https://mangkyu.tistory.com/102">참고1</a>
</div>
</details>
<hr>

## 12. hash table에서 충돌 상황이 발생할 때는 언제인가요?

<details>
<summary>12번 정답</summary>
<div markdown="1">
충돌이란 서로 다른 key의 해시값이 똑같을 때를 말합니다.<br> 즉 key 자체는 중복되지 않아도 해시 함수를 통해 고유한 index를 생성할 때, 중복될 수 있는데 이 떄 충돌이 발생합니다.
<a href="https://mangkyu.tistory.com/102">참고1</a>
</div>
</details>
<hr>

## 13. 좋은 해시 함수의 조건은 무엇일까요?

<details>
<summary>13번 정답</summary>
<div markdown="1">
상황에 따라 달라질 수 있지만, 대략적인 기준으로는 연산 속도가 빨라야하고 해시값이 최대한 겹치지 않아야 합니다.
<a href="https://mangkyu.tistory.com/102">참고1</a>
</div>
</details>
<hr>

## 14. 해시 테이블의 충돌을 막을 방법에는 무엇이 있을까요?

<details>
<summary>14번 정답</summary>
<div markdown="1">
대표적으로 open addressing 방식과 seperate chaining 방식이 있습니다.<br>
open addressing 방식은 충돌이 발생할 때, 미리 정한 규칙에 따라 hash table의 비어있는 공간을 찾습니다. <br>
seperate chaining 방식은 연결리스트를 사용합니다. 만약에 충돌이 발생하면 연결리스트 노드에 추가하여 데이터를 저장합니다.
<a href="https://mangkyu.tistory.com/102">참고1</a>
</div>
</details>
<hr>

## stack 두 개를 이용하여 queue를 구현해보는 것, queue 두 개를 이용하여 stack을 구현해보는 것 생각해보기
